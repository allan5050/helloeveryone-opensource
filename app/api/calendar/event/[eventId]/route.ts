import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { requireAuth } from '@/lib/api/auth'
import { createEvent, EventAttributes } from 'ics'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ eventId: string }> }
) {
  try {
    const user = await requireAuth(request)
    const { eventId } = await params

    const supabase = await createClient()

    // Fetch event details with location and organizer
    const { data: event, error: eventError } = await supabase
      .from('events')
      .select(
        `
        *,
        profiles!events_organizer_id_fkey (
          first_name,
          last_name,
          email
        )
      `
      )
      .eq('id', eventId)
      .single()

    if (eventError || !event) {
      return NextResponse.json({ error: 'Event not found' }, { status: 404 })
    }

    // Check if user has RSVP'd to this event
    const { data: rsvp } = await supabase
      .from('rsvps')
      .select('status')
      .eq('event_id', eventId)
      .eq('profile_id', user.id)
      .single()

    if (!rsvp || rsvp.status !== 'going') {
      return NextResponse.json(
        { error: 'You must RSVP to this event to add it to your calendar' },
        { status: 403 }
      )
    }

    // Fetch attendees who are going
    const { data: attendees } = await supabase
      .from('rsvps')
      .select(
        `
        profiles (
          first_name,
          last_name
        )
      `
      )
      .eq('event_id', eventId)
      .eq('status', 'going')

    // Fetch user's matches who are also attending
    const { data: matches } = await supabase
      .from('match_scores')
      .select(
        `
        profile2_id,
        score,
        profiles!match_scores_profile2_id_fkey (
          first_name,
          last_name
        )
      `
      )
      .eq('profile1_id', user.id)
      .gte('score', 0.7) // Only include good matches
      .in(
        'profile2_id',
        attendees?.map(a => a.profiles?.id).filter(Boolean) || []
      )

    // Parse date and time
    const startDate = new Date(event.date + 'T' + event.time)
    const endDate = new Date(
      startDate.getTime() + (event.duration || 120) * 60000
    ) // Default 2 hours

    // Build description with matches and attendees
    let description = event.description || ''

    if (matches && matches.length > 0) {
      description += '\n\nðŸŽ¯ YOUR MATCHES ATTENDING:\n'
      matches.forEach(match => {
        const profile = match.profiles
        if (profile) {
          description += `â€¢ ${profile.first_name} ${profile.last_name} (${Math.round(match.score * 100)}% match)\n`
        }
      })
    }

    if (attendees && attendees.length > 0) {
      description += `\n\nðŸ‘¥ OTHER ATTENDEES (${attendees.length} total):\n`
      attendees
        .slice(0, 10) // Limit to first 10 to avoid overly long descriptions
        .forEach(attendee => {
          const profile = attendee.profiles
          if (profile && !matches?.find(m => m.profiles?.id === profile.id)) {
            description += `â€¢ ${profile.first_name} ${profile.last_name}\n`
          }
        })

      if (attendees.length > 10) {
        description += `... and ${attendees.length - 10} more attendees\n`
      }
    }

    description += '\n\nGenerated by HelloEveryone.fun - Smart Social Matching'

    // Create ICS event
    const eventAttributes: EventAttributes = {
      start: [
        startDate.getFullYear(),
        startDate.getMonth() + 1,
        startDate.getDate(),
        startDate.getHours(),
        startDate.getMinutes(),
      ],
      end: [
        endDate.getFullYear(),
        endDate.getMonth() + 1,
        endDate.getDate(),
        endDate.getHours(),
        endDate.getMinutes(),
      ],
      title: event.name,
      description,
      location: event.location,
      url: `${process.env.NEXT_PUBLIC_APP_URL || 'https://helloeveryone.fun'}/events/${eventId}`,
      organizer: {
        name: event.profiles
          ? `${event.profiles.first_name} ${event.profiles.last_name}`
          : 'HelloEveryone.fun',
        email: event.profiles?.email || 'hello@helloeveryone.fun',
      },
      attendees:
        attendees?.map(attendee => ({
          name: attendee.profiles
            ? `${attendee.profiles.first_name} ${attendee.profiles.last_name}`
            : 'Attendee',
          email: 'attendee@helloeveryone.fun', // Placeholder for privacy
          rsvp: true,
        })) || [],
      alarms: [
        {
          action: 'display',
          description: `Reminder: ${event.name} starts in 1 hour`,
          trigger: { hours: 1, minutes: 0, before: true },
        },
        {
          action: 'display',
          description: `Reminder: ${event.name} starts in 30 minutes`,
          trigger: { hours: 0, minutes: 30, before: true },
        },
      ],
    }

    // Generate ICS content
    const { error: icsError, value: icsContent } = createEvent(eventAttributes)

    if (icsError) {
      console.error('ICS generation error:', icsError)
      return NextResponse.json(
        { error: 'Failed to generate calendar file' },
        { status: 500 }
      )
    }

    // Return ICS file
    return new NextResponse(icsContent, {
      headers: {
        'Content-Type': 'text/calendar; charset=utf-8',
        'Content-Disposition': `attachment; filename="${event.name.replace(/[^a-zA-Z0-9]/g, '_')}.ics"`,
        'Cache-Control': 'no-cache',
      },
    })
  } catch (error) {
    console.error('Calendar API error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
