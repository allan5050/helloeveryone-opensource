import { createEvent, EventAttributes } from 'ics'
import { NextRequest, NextResponse } from 'next/server'

import { requireAuth } from '@/lib/api/auth'
import { createClient } from '@/lib/supabase/server'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ eventId: string }> }
) {
  try {
    const user = await requireAuth(request)
    const { eventId } = await params

    const supabase = await createClient()

    // Fetch event details with location and organizer
    const { data: event, error: eventError } = await supabase
      .from('events')
      .select('*')
      .eq('id', eventId)
      .single()

    // Fetch organizer profile separately using created_by
    const { data: organizer } = event
      ? await supabase
          .from('profiles')
          .select('first_name, last_name')
          .eq('user_id', event.created_by)
          .single()
      : { data: null }

    if (eventError || !event) {
      return NextResponse.json({ error: 'Event not found' }, { status: 404 })
    }

    // Check if user has RSVP'd to this event
    const { data: rsvp } = await supabase
      .from('rsvps')
      .select('status')
      .eq('event_id', eventId)
      .eq('user_id', user.id)
      .single()

    if (!rsvp || rsvp.status !== 'going') {
      return NextResponse.json(
        { error: 'You must RSVP to this event to add it to your calendar' },
        { status: 403 }
      )
    }

    // Fetch attendees who are going
    const { data: attendees } = await supabase
      .from('rsvps')
      .select('user_id')
      .eq('event_id', eventId)
      .eq('status', 'going')

    // Get attendee user IDs for match lookup
    const attendeeUserIds = attendees?.map(a => a.user_id).filter(Boolean) || []

    // Fetch profiles for attendees
    const { data: attendeeProfiles } = await supabase
      .from('profiles')
      .select('user_id, first_name, last_name')
      .in('user_id', attendeeUserIds)

    // Fetch user's matches who are also attending
    const { data: matches } = await supabase
      .from('match_scores')
      .select('user_id_2, combined_score')
      .eq('user_id_1', user.id)
      .gte('combined_score', 0.7) // Only include good matches
      .in('user_id_2', attendeeUserIds)

    // Get match profiles
    const matchUserIds = matches?.map(m => m.user_id_2).filter(Boolean) || []
    const { data: matchProfiles } = await supabase
      .from('profiles')
      .select('user_id, first_name, last_name')
      .in('user_id', matchUserIds)

    // Parse start and end times from event
    const startDate = new Date(event.start_time)
    const endDate = new Date(event.end_time)

    // Build description with matches and attendees
    let description = event.description || ''

    if (matches && matches.length > 0 && matchProfiles) {
      description += '\n\nYOUR MATCHES ATTENDING:\n'
      matches.forEach(match => {
        const profile = matchProfiles.find(p => p.user_id === match.user_id_2)
        if (profile) {
          description += `- ${profile.first_name} ${profile.last_name} (${Math.round(match.combined_score * 100)}% match)\n`
        }
      })
    }

    if (attendeeProfiles && attendeeProfiles.length > 0) {
      description += `\n\nOTHER ATTENDEES (${attendeeProfiles.length} total):\n`
      attendeeProfiles
        .filter(p => !matchUserIds.includes(p.user_id))
        .slice(0, 10) // Limit to first 10 to avoid overly long descriptions
        .forEach(profile => {
          description += `- ${profile.first_name} ${profile.last_name}\n`
        })

      if (attendeeProfiles.length > 10) {
        description += `... and ${attendeeProfiles.length - 10} more attendees\n`
      }
    }

    description += '\n\nGenerated by HelloEveryone.fun - Smart Social Matching'

    // Create ICS event
    const eventAttributes: EventAttributes = {
      start: [
        startDate.getFullYear(),
        startDate.getMonth() + 1,
        startDate.getDate(),
        startDate.getHours(),
        startDate.getMinutes(),
      ],
      end: [
        endDate.getFullYear(),
        endDate.getMonth() + 1,
        endDate.getDate(),
        endDate.getHours(),
        endDate.getMinutes(),
      ],
      title: event.title,
      description,
      location: event.location,
      url: `${process.env.NEXT_PUBLIC_APP_URL || 'https://helloeveryone.fun'}/events/${eventId}`,
      organizer: {
        name: organizer
          ? `${organizer.first_name} ${organizer.last_name}`
          : 'HelloEveryone.fun',
        email: 'hello@helloeveryone.fun', // Use placeholder for privacy
      },
      attendees:
        attendeeProfiles?.map(profile => ({
          name: `${profile.first_name} ${profile.last_name}`,
          email: 'attendee@helloeveryone.fun', // Placeholder for privacy
          rsvp: true,
        })) || [],
    }

    // Generate ICS content
    const { error: icsError, value: icsContent } = createEvent(eventAttributes)

    if (icsError) {
      console.error('ICS generation error:', icsError)
      return NextResponse.json(
        { error: 'Failed to generate calendar file' },
        { status: 500 }
      )
    }

    // Return ICS file
    return new NextResponse(icsContent, {
      headers: {
        'Content-Type': 'text/calendar; charset=utf-8',
        'Content-Disposition': `attachment; filename="${event.title.replace(/[^a-zA-Z0-9]/g, '_')}.ics"`,
        'Cache-Control': 'no-cache',
      },
    })
  } catch (error) {
    console.error('Calendar API error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
