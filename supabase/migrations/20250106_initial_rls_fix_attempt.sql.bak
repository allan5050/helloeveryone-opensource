-- Fix RLS Recursion Issues for HelloEveryone
-- This script properly configures RLS policies to avoid infinite recursion

-- Step 1: Drop all existing RLS policies to start fresh
DO $$ 
DECLARE
    r RECORD;
BEGIN
    -- Drop all policies on all tables
    FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            'select_' || r.tablename, r.tablename);
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            'insert_' || r.tablename, r.tablename);
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            'update_' || r.tablename, r.tablename);
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            'delete_' || r.tablename, r.tablename);
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            'admin_all_' || r.tablename, r.tablename);
        -- Also drop any other existing policies
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            r.tablename || '_select', r.tablename);
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            r.tablename || '_insert', r.tablename);
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            r.tablename || '_update', r.tablename);
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            r.tablename || '_delete', r.tablename);
        -- Drop admin policies
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            'admin_bypass_' || r.tablename, r.tablename);
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I CASCADE', 
            'admin_all_' || r.tablename, r.tablename);
    END LOOP;
END $$;

-- Step 2: Use the built-in auth.uid() function directly (no need for custom function)

-- Step 3: Enable RLS on all tables
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE events ENABLE ROW LEVEL SECURITY;
ALTER TABLE rsvps ENABLE ROW LEVEL SECURITY;
ALTER TABLE match_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE blocks ENABLE ROW LEVEL SECURITY;
ALTER TABLE meeting_slots ENABLE ROW LEVEL SECURITY;

-- Step 4: Create NON-RECURSIVE policies for profiles table
-- Profiles can be viewed by anyone authenticated (no recursion)
CREATE POLICY "profiles_select" ON profiles
    FOR SELECT TO authenticated
    USING (true);

-- Users can only update their own profile
CREATE POLICY "profiles_update" ON profiles
    FOR UPDATE TO authenticated
    USING (user_id = auth.uid());

-- Users can insert their own profile
CREATE POLICY "profiles_insert" ON profiles
    FOR INSERT TO authenticated
    WITH CHECK (user_id = auth.uid());

-- Step 5: Create policies for events table WITHOUT profile checks
-- Events can be viewed by anyone authenticated
CREATE POLICY "events_select" ON events
    FOR SELECT TO authenticated
    USING (is_active = true);

-- Users can create events
CREATE POLICY "events_insert" ON events
    FOR INSERT TO authenticated
    WITH CHECK (created_by = auth.uid());

-- Users can update their own events
CREATE POLICY "events_update" ON events
    FOR UPDATE TO authenticated
    USING (created_by = auth.uid());

-- Users can delete their own events
CREATE POLICY "events_delete" ON events
    FOR DELETE TO authenticated
    USING (created_by = auth.uid());

-- Step 6: Create policies for RSVPs
CREATE POLICY "rsvps_select" ON rsvps
    FOR SELECT TO authenticated
    USING (
        user_id = auth.uid() 
        OR event_id IN (SELECT id FROM events WHERE created_by = auth.uid())
    );

CREATE POLICY "rsvps_insert" ON rsvps
    FOR INSERT TO authenticated
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "rsvps_update" ON rsvps
    FOR UPDATE TO authenticated
    USING (user_id = auth.uid());

CREATE POLICY "rsvps_delete" ON rsvps
    FOR DELETE TO authenticated
    USING (user_id = auth.uid());

-- Step 7: Create policies for match_scores
CREATE POLICY "match_scores_select" ON match_scores
    FOR SELECT TO authenticated
    USING (
        user_id_1 = auth.uid() 
        OR user_id_2 = auth.uid()
    );

CREATE POLICY "match_scores_insert" ON match_scores
    FOR INSERT TO authenticated
    WITH CHECK (false); -- Only system can insert

CREATE POLICY "match_scores_update" ON match_scores
    FOR UPDATE TO authenticated
    USING (false); -- Only system can update

-- Step 8: Create policies for messages
CREATE POLICY "messages_select" ON messages
    FOR SELECT TO authenticated
    USING (
        sender_id = auth.uid() 
        OR recipient_id = auth.uid()
    );

CREATE POLICY "messages_insert" ON messages
    FOR INSERT TO authenticated
    WITH CHECK (sender_id = auth.uid());

CREATE POLICY "messages_update" ON messages
    FOR UPDATE TO authenticated
    USING (sender_id = auth.uid() AND created_at > NOW() - INTERVAL '5 minutes');

-- Step 9: Create policies for favorites
CREATE POLICY "favorites_select" ON favorites
    FOR SELECT TO authenticated
    USING (user_id = auth.uid());

CREATE POLICY "favorites_insert" ON favorites
    FOR INSERT TO authenticated
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "favorites_delete" ON favorites
    FOR DELETE TO authenticated
    USING (user_id = auth.uid());

-- Step 10: Create policies for blocks
CREATE POLICY "blocks_select" ON blocks
    FOR SELECT TO authenticated
    USING (blocker_id = auth.uid());

CREATE POLICY "blocks_insert" ON blocks
    FOR INSERT TO authenticated
    WITH CHECK (blocker_id = auth.uid());

CREATE POLICY "blocks_delete" ON blocks
    FOR DELETE TO authenticated
    USING (blocker_id = auth.uid());

-- Step 11: Create policies for meeting_slots
CREATE POLICY "meeting_slots_select" ON meeting_slots
    FOR SELECT TO authenticated
    USING (
        user_id_1 = auth.uid() 
        OR user_id_2 = auth.uid()
        OR event_id IN (SELECT id FROM events WHERE is_active = true)
    );

CREATE POLICY "meeting_slots_insert" ON meeting_slots
    FOR INSERT TO authenticated
    WITH CHECK (user_id_1 = auth.uid() OR user_id_2 = auth.uid());

CREATE POLICY "meeting_slots_update" ON meeting_slots
    FOR UPDATE TO authenticated
    USING (user_id_1 = auth.uid() OR user_id_2 = auth.uid());

CREATE POLICY "meeting_slots_delete" ON meeting_slots
    FOR DELETE TO authenticated
    USING (user_id_1 = auth.uid() OR user_id_2 = auth.uid());

-- Step 12: Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;

-- Step 13: Create admin bypass policies (optional, only if needed)
DO $$
BEGIN
    -- Check if any user has admin role
    IF EXISTS (SELECT 1 FROM profiles WHERE role = 'admin'::user_role) THEN
        -- Create admin policies for all tables
        CREATE POLICY "admin_bypass_profiles" ON profiles
            FOR ALL TO authenticated
            USING (EXISTS (
                SELECT 1 FROM profiles 
                WHERE user_id = auth.uid() 
                AND role = 'admin'::user_role
            ));
            
        CREATE POLICY "admin_bypass_events" ON events
            FOR ALL TO authenticated
            USING (EXISTS (
                SELECT 1 FROM profiles 
                WHERE user_id = auth.uid() 
                AND role = 'admin'::user_role
            ));
    END IF;
END $$;

-- Verification query - run this to check policies are applied
SELECT 
    schemaname,
    tablename,
    policyname,
    permissive,
    roles,
    cmd
FROM pg_policies 
WHERE schemaname = 'public'
ORDER BY tablename, policyname;